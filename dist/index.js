class ${x;y;constructor(v,F){this.x=v,this.y=F}equals(v){return this.x==v.x&&this.y==v.y}add(v){return new $(this.x+v.x,this.y+v.y)}scalarMultiply(v){this.x*=v,this.y*=v}dot(v){return this.x*v.x+this.y+v.y}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}}function H(){return Math.sign(Math.random()-0.5)}function I(v,F,U){return Math.min(Math.max(v,F),U)}class J{mass;screen;pos;velocity;collided;constructor(v){this.screen=v,this.mass=Math.random()*3+2,this.pos=new $(v.x*0.375*Math.random(),v.y*0.375*Math.random()),this.velocity=new $(Math.max(Math.random()*2,0.2)*H(),Math.max(Math.random()*2,0.2)*H()),this.collided=!1}update(){const v=this.pos.x+this.velocity.x;if(v<this.mass||this.pos.x>this.screen.x-this.mass)this.velocity.x=-this.velocity.x,this.pos.x+=this.velocity.x;else this.pos.x=v;const F=this.pos.y+this.velocity.y;if(F<this.mass||this.pos.y>this.screen.y-this.mass)this.velocity.y=-this.velocity.y,this.pos.y+=this.velocity.y;else this.pos.y=F}collision(v){const F=new $(v.pos.x-this.pos.x,v.pos.y-this.pos.y);if(Math.pow(F.x,2)+Math.pow(F.y,2)<=Math.pow(this.mass+v.mass,2))this.collided=!0,v.collided=!0}render(v){v.fillStyle=this.collided?"red":"green",v.beginPath(),v.arc(this.pos.x,this.pos.y,this.mass,0,Math.PI*2),v.fill()}}var L=5;class k{subTrees;occupants;min;max;depth;constructor(v,F,U=0){this.subTrees=null,this.occupants=[],this.min=v,this.max=F,this.depth=U}render(v){if(v.beginPath(),v.moveTo(this.min.x,this.min.y),v.lineTo(this.max.x,this.min.y),v.lineTo(this.max.x,this.max.y),v.lineTo(this.min.x,this.max.y),v.lineTo(this.min.x,this.min.y),v.closePath(),v.stroke(),this.subTrees!==null)for(let F=0;F<4;++F)this.subTrees[F].render(v)}insert(v){if(!this.inBounds(v))return;if(this.occupants===null){this.addToSubTrees(v);return}if(this.occupants.length<4||this.depth>=L){if(!this.occupants.includes(v))this.occupants.push(v);return}this.createSubTrees(),this.addToSubTrees(v),this.occupants=null}physicsUpdate(){if(this.occupants===null){this.subTrees[0].physicsUpdate(),this.subTrees[1].physicsUpdate(),this.subTrees[2].physicsUpdate(),this.subTrees[3].physicsUpdate();return}const v=this.occupants.length;for(let F=0;F<v;++F){const U=this.occupants[F];for(let b=F+1;b<v;++b)U.collision(this.occupants[b])}}update(){const v=this.moveOutOfBoundsEntities(),F=v.length;for(let U=0;U<F;++U)this.insert(v[U]);this.cleanUpTreesFromMovingEntities()}moveOutOfBoundsEntities(){let v=[];if(this.occupants===null){v=v.concat(this.subTrees[0].moveOutOfBoundsEntities()).concat(this.subTrees[1].moveOutOfBoundsEntities()).concat(this.subTrees[2].moveOutOfBoundsEntities()).concat(this.subTrees[3].moveOutOfBoundsEntities());for(let F=0;F<v.length;++F){const U=v[F];if(this.inBounds(U))this.insert(U),v.splice(F,1),--F}return v}for(let F=0;F<this.occupants.length;++F){const U=this.occupants[F];if(!this.inBounds(U))v.push(U),this.occupants.splice(F,1),--F}return v}cleanUpTreesFromMovingEntities(){if(this.subTrees===null)return;let v=0;for(;v<4;++v)this.subTrees[v].cleanUpTreesFromMovingEntities();let F=0;for(v=0;v<4;++v){if(this.subTrees[v].subTrees!==null){F+=5;break}F+=this.subTrees[v].occupants.length}if(F<=4){this.occupants=[];for(v=0;v<4;++v){const U=this.subTrees[v].occupants,b=U.length;for(let g=0;g<b;++g)if(!this.occupants.includes(U[g]))this.occupants.push(U[g])}this.subTrees=null}}addToSubTrees(v){let F=!1;for(let U=0;U<4;++U)F||=this.subTrees[U].inBounds(v);if(!F&&this.depth>=1){console.log("oh no");for(let U=0;U<4;++U)F||=this.subTrees[U].inBounds(v)}this.subTrees[0].insert(v),this.subTrees[1].insert(v),this.subTrees[2].insert(v),this.subTrees[3].insert(v)}createSubTrees(){const v=this.depth+1,F=(this.min.x+this.max.x)/2,U=(this.min.y+this.max.y)/2;this.subTrees=[new k(new $(F,this.min.y),new $(this.max.x,U),v),new k(new $(this.min.x,this.min.y),new $(F,U),v),new k(new $(F,U),new $(this.max.x,this.max.y),v),new k(new $(this.min.x,U),new $(F,this.max.y),v)],this.addToSubTrees(this.occupants[0]),this.addToSubTrees(this.occupants[1]),this.addToSubTrees(this.occupants[2]),this.addToSubTrees(this.occupants[3])}inBounds(v){const F=v.pos.x,U=v.pos.y,b=v.mass,g=F-I(F,this.min.x,this.max.x),G=U-I(U,this.min.y,this.max.y);return g*g+G*G<=b*b}}class K{screen;canvas;ctx;entities;qTree;constructor(){this.screen=new $(720,480),this.canvas=document.createElement("canvas"),this.canvas.setAttribute("id","canvas"),this.canvas.setAttribute("width",`${this.screen.x}`),this.canvas.setAttribute("height",`${this.screen.y}`),document.getElementById("canvashere").appendChild(this.canvas),this.ctx=this.canvas.getContext("2d"),this.ctx.fillStyle="green",this.ctx.lineWidth=0.2,this.ctx.strokeStyle="white",this.qTree=new k(new $(0,0),this.screen),this.entities=[];for(let v=0;v<1000;++v){const F=new J(this.screen);this.entities.push(F),this.qTree.insert(F)}}start(){let v=30,F=performance.now(),U=!0;const b=()=>{const g=performance.now();v=Math.round(1000/(g-F)),F=g,this.ctx.clearRect(0,0,this.screen.x,this.screen.y),this.ctx.font="20px Arial",this.ctx.fillStyle="white",this.ctx.fillText(`FPS: ${v}`,this.screen.x-90,this.screen.y);const G=this.entities.length;let C=0;this.qTree.update(),this.qTree.physicsUpdate();for(C=0;C<G;++C)this.entities[C].update(),this.entities[C].render(this.ctx),this.entities[C].collided=!1;this.qTree.render(this.ctx),window.requestAnimationFrame(b)};window.requestAnimationFrame(b)}}document.body.onload=()=>{new K().start()};
